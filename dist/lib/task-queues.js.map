{"version":3,"sources":["task-queues.js"],"names":[],"mappings":"uwBAAA,IAAI,OAAO,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;;AAErB,KAAK;AACL,WADA,KAAK,GACF,uBADH,KAAK;AAEd,QAAI,CAAC,WAAW,GAAG,IAAI,CAAC;AACxB,QAAI,CAAC,WAAW,GAAG,EAAE,CAAC;;AAEtB,QAAI,CAAC,YAAY,GAAG,IAAI,CAAC;AACzB,QAAI,CAAC,YAAY,GAAG,IAAI,CAAC,CAC1B,aAPU,KAAK;;;AASR,sBAAC,IAAI,EAAE;AACb,UAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC5B,UAAI,CAAC,IAAI,CAAC,YAAY,EAAE;AACtB,YAAI,CAAC,YAAY,GAAG,IAAI,OAAO,CAAC,UAAC,OAAO,EAAK;AAC3C,gBAAK,YAAY,GAAG,OAAO,CAAC,CAC7B,CAAC,CAAC,CACJ;;;AACD,UAAI,CAAC,WAAW,EAAE,CAAC,CACpB;;;AAEU,2BAAG;AACZ,aAAO,AAAC,CAAC,IAAI,CAAC,WAAW,IAAM,IAAI,CAAC,WAAW,CAAC,MAAM,AAAC,EAAE;;AAEvD,YAAI,IAAI,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;;AAEvD,YAAI,aAAa,GAAG,IAAI,EAAE,CAAC;;AAE3B,YAAI,aAAa,IAAI,aAAa,CAAC,IAAI,EAAE;;AAEvC,uBAAa,CAAC,IAAI,CAAC,YAAM;AACvB,mBAAK,WAAW,GAAG,IAAI,CAAC;AACxB,mBAAK,WAAW,EAAE,CAAC,CACpB,CAAC,SAAM;AAAC,oBAAC,GAAG,EAAK;;AAEhB,mBAAK,WAAW,GAAG,IAAI,CAAC;AACxB,sBAAU,CAAC,OAAK,WAAW,CAAC,IAAI,QAAM,EAAE,CAAC,CAAC,CAAC;;AAE3C,kBAAM,GAAG,CAAC,CACX,CAAC,CAAC,CACJ;;AAAM;;AAEL,cAAI,CAAC,WAAW,GAAG,IAAI,CAAC,CACzB,CACF;;;;AAED,UAAI,AAAC,CAAC,IAAI,CAAC,WAAW,IAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,AAAC,EAAE;;AAErD,YAAI,CAAC,YAAY,EAAE,CAAC;AACpB,YAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,CAC9C,CACF;;;;;;;;AAMU,yBAAC,EAAE,EAAE;AACd,UAAI,KAAK,GAAG,IAAI,CAAC;AACjB,aAAO,YAAkB,mCAAN,IAAI,gDAAJ,IAAI;AACrB,aAAK,CAAC,QAAQ,CAAC,YAAM;AACnB,iBAAO,EAAE,kBAAI,IAAI,CAAC,CAAC,CACpB,CAAC,CAAC,CACJ,CAAA,CACF;;;;;AAEa,8BAAG;AACf,aAAO,IAAI,CAAC,YAAY,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC,CAC/C,YAlEU,KAAK","file":"task-queues.js","sourcesContent":["let Promise = require('bluebird');\n\nexport class Queue {\n  constructor() {\n    this.runningTask = null;\n    this.queuedTasks = [];\n\n    this.emptyPromise = null;\n    this.triggerEmpty = null;\n  }\n\n  schedule(task) {\n    this.queuedTasks.push(task);\n    if (!this.emptyPromise) {\n      this.emptyPromise = new Promise((resolve) => {\n        this.triggerEmpty = resolve;\n      });\n    }\n    this.runNextTask();\n  }\n\n  runNextTask() {\n    while ((!this.runningTask) && (this.queuedTasks.length)) {\n      // pick next task\n      let task = this.runningTask = this.queuedTasks.shift();\n      // start it!\n      let maybeAPromise = task();\n\n      if (maybeAPromise && maybeAPromise.then) {\n        // the task returned a promise, so we'll wait for it to resolve\n        maybeAPromise.then(() => {\n          this.runningTask = null;\n          this.runNextTask();\n        }).catch((err) => {\n          // if it resolves with an error, we still have to manage the queue\n          this.runningTask = null;\n          setTimeout(this.runNextTask.bind(this), 0);\n          // but we rethrow the error anyway\n          throw err;\n        });\n      } else {\n        // the task didn't return a promise, meaning we can mark it as done synchronously\n        this.runningTask = null;\n      }\n    }\n\n    if ((!this.runningTask) && (!this.queuedTasks.length)) {\n      // out of tasks?\n      this.triggerEmpty();\n      this.emptyPromise = this.triggerEmpty = null;\n    }\n  }\n\n  /**\n    Takes a function and returns the same function synchronized with this queue. This means\n    that this function's execution will always be delayed until nothing else is in this queue.\n   **/\n  synchronize(fn) {\n    let queue = this;\n    return function(...args) {\n      queue.schedule(() => {\n        return fn(...args);\n      });\n    }\n  }\n\n  waitUntilEmpty() {\n    return this.emptyPromise || Promise.resolve();\n  }\n}\n"],"sourceRoot":"../../lib"}