{"version":3,"sources":["plugins/views.js"],"names":[],"mappings":";;;;;AAKwB,KAAK,qBAHA,SAAS,4BAChB,gBAAgB,EAHtC,IAAI,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,AAKX,SAAS,KAAK,CAAC,OAAO,EAAE;AACrC,SAAO,UAJA,YAAY,EAIC,WAAW,EAAE,CAAC,OAAO,CAAC,EAAE,aAAa,CAAC,CAAC,CAC5D;;;AAED,SAAS,WAAW,GAAG;AACrB,MAAI,CAAC,cAAc,GAAG,gBAPf,KAAK,EAOqB,CAAC,CACnC;;AACD,WAAW,CAAC,SAAS,GAAG;AACtB,aAAW,EAAA,qBAAC,CAAC,EAAE;AACb,QAAI,CAAC,CAAC,GAAG,CAAC,CAAC;AACX,WAAO;AACL,aAAO,EAAE;AACP,iBAAS,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,EACrC;;AACD,iBAAW,EAAE;AACX,aAAK,EAAE,KAAK,EACb,EACF,CAAA,CACF;;;;;AAED,WAAS,EAAA,mBAAC,EAAE,EAAE;AACZ,QAAI,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;AACjD,UAAM,CAAC,UAAU,GAAG,IAAI,CAAC;AACzB,WAAO,MAAM,CAAC,CACf,EACF,CAAC;;;;AAEF,IAAM,MAAM,GAAG,CAAC,SAAS,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;;AAEnD,SAAS,KAAK,CAAC,MAAM,EAAE;;;AAGrB,MAAI,cAAc,GAAG,EAAE,CAAC;AACxB,MAAI,IAAI,GAAG,IAAI,CAAC;;;;AAIhB,QAAM,CAAC,OAAO,CAAC,UAAC,SAAS,EAAK;AAC5B,QAAI,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;AAC/B,QAAI,MAAM,IAAK,OAAO,MAAM,IAAI,UAAU,AAAC,EAAE;AAC3C,UAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACnC,UAAI,CAAC,QAAQ,CAAC,UAAU;AACtB,cAAQ,GAAG,MAAK,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;;AAExC,UAAI,CAAC,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;AAC7B,oBAAc,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAC,CAAC,CAAC,CAC7D,CACF,CAAC,CAAC;;;;;;AAIH,MAAI,cAAc,GAAG,SAAjB,cAAc,GAAS;AACzB,KAAC,CAAC,IAAI,CAAC,cAAc,EAAE,UAAC,IAAiB,EAAK,KAArB,KAAK,GAAN,IAAiB,CAAhB,KAAK,KAAE,QAAQ,GAAhB,IAAiB,CAAT,QAAQ;AACtC,UAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAC3B,CAAC,CAAC,CACJ,CAAC;;;AACF,MAAI,CAAC,EAAE,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;AACrC,gBAAc,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,cAAc,EAAC,CAAC,CAAC,CACrE","file":"plugins/views.js","sourcesContent":["let _ = require('lodash');\n\nimport { functionized } from '../util';\nimport { Queue } from '../task-queues';\n\nexport default function views(options) {\n  return functionized(ViewsPlugin, [options], 'applyPlugin');\n}\n\nfunction ViewsPlugin() {\n  this.animationQueue = new Queue();\n}\nViewsPlugin.prototype = {\n  applyPlugin(u) {\n    this.u = u;\n    return {\n      methods: {\n        animation: this.animation.bind(this)\n      },\n      nodeMethods: {\n        watch: watch\n      }\n    }\n  },\n\n  animation(fn) {\n    let synced = this.animationQueue.synchronize(fn);\n    synced._animation = true;\n    return synced;\n  }\n};\n\nconst EVENTS = ['updated', 'destroyed', 'created'];\n\nfunction watch(object) {\n  // 'this' here will refer to the node .watch() was called on\n\n  let boundListeners = [];\n  let node = this;\n\n  // scan all methods of the object looking for matches with event names\n  // register all such methods as listeners\n  EVENTS.forEach((eventName) => {\n    let method = object[eventName];\n    if (method && (typeof method == 'function')) {\n      let listener = method.bind(object);\n      if (!listener._animation)\n        listener = this.u.animation(listener);\n\n      node.on(eventName, listener);\n      boundListeners.push({event: eventName, listener: listener});\n    }\n  });\n\n  // when the node we are watching gets destroyed, we want to unbind all those listeners\n  // (including the listener that keeps track of it)\n  let unbindListener = () => {\n    _.each(boundListeners, ({event, listener}) => {\n      node.off(event, listener);\n    });\n  };\n  node.on('destroyed', unbindListener);\n  boundListeners.push({event: 'destroyed', listener: unbindListener});\n}\n"],"sourceRoot":"../../../lib"}